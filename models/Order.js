const mongoose = require('mongoose');

const orderItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  productName: {
    type: String,
    required: true,
    trim: true
  },
  narration: {
    type: String,
    trim: true,
    default: ''
  },
  price: {
    type: Number,
    required: true,
    min: 0
  },
  quantity: {
    type: Number,
    required: true,
    min: [0.01, 'Quantity must be greater than 0']
  },
  deliveredQuantity: {
    type: Number,
    default: 0,
    min: 0
  },
  remainingQuantity: {
    type: Number,
    default: function() {
      return this.quantity;
    },
    min: 0
  },
  total: {
    type: Number,
    required: true
  },
  
  // â”€â”€ Parda-specific fields (only for products starting with "Parda") â”€â”€
  // These are optional â€” only populated when the product is a Parda/curtain
  width: {
    type: Number,
    min: 0
  },
  height: {
    type: Number,
    min: 0
  },
  chunnut: {
    type: Number,
    min: 0
  },
  colour: {
    type: String,
    trim: true
  },
  colourPrice: {
    type: Number,
    min: 0
  }
}, { _id: false });

const orderSchema = new mongoose.Schema({
  orderNumber: {
    type: String,
    unique: true,
    index: true
  },
  // Party Details
  partyName: {
    type: String,
    required: [true, 'Party name is required'],
    trim: true,
    index: true
  },
  mobile: {
    type: String,
    required: [true, 'Mobile number is required'],
    trim: true,
    index: true
  },
  client: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Client',
    index: true
  },
  // Order Items
  items: [orderItemSchema],
  
  // Pricing
  subtotal: {
    type: Number,
    required: true,
    min: 0
  },
  localFreight: {
    type: Number,
    default: 0,
    min: 0
  },
  transportation: {
    type: Number,
    default: 0,
    min: 0
  },
  gstPercent: {
    type: Number,
    default: 0,
    min: 0,
    max: 100
  },
  gstAmount: {
    type: Number,
    default: 0,
    min: 0
  },
  discount: {
    type: Number,
    default: 0,
    min: 0
  },
  grandTotal: {
    type: Number,
    required: true,
    min: 0
  },
  advance: {
    type: Number,
    default: 0,
    min: 0
  },
  balanceDue: {
    type: Number,
    required: true
  },
  
  // Dates
  orderDate: {
    type: Date,
    default: Date.now,
    index: true
  },
  expectedDeliveryDate: {
    type: Date,
    index: true
  },
  
  // Order Status
  status: {
    type: String,
    enum: ['open', 'in_progress', 'partial_delivered', 'delivered', 'completed', 'cancelled'],
    default: 'open',
    index: true
  },
  paymentStatus: {
    type: String,
    enum: ['unpaid', 'partial', 'paid'],
    default: 'unpaid',
    index: true
  },
  
  // Progress tracking
  progress: {
    type: Number,
    default: 0,
    min: 0,
    max: 100
  },
  
  // Delivery tracking
  totalDeliveries: {
    type: Number,
    default: 0
  },
  
  // â”€â”€ Return Tracking â”€â”€
  // returnedAmount: total monetary value of all returned items (grandTotal stays unchanged for audit)
  // effectiveTotal = grandTotal - returnedAmount (what the client actually owes for kept items)
  returnedAmount: {
    type: Number,
    default: 0,
    min: 0
  },
  totalReturns: {
    type: Number,
    default: 0
  },
  
  // Employee tracking
  employeeName: {
    type: String,
    trim: true,
    index: true
  },
  employee: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },
  
  // Customization comments (not shown in invoice)
  comment: {
    type: String,
    trim: true
  },
  
  // Delivery performance tracking
  actualDeliveryDate: {
    type: Date,
    index: true
  },
  deliveryPerformance: {
    type: String,
    enum: ['on_time', 'early', 'late', null],
    default: null,
    index: true
  },
  
  // Fast Order flag (POS counter sale â€” no client, no delivery tracking, instant completion)
  isFastOrder: {
    type: Boolean,
    default: false,
    index: true
  },
  
  // Order locking (read-only when completed)
  isLocked: {
    type: Boolean,
    default: false,
    index: true
  },
  
  // Cancellation tracking
  cancelReason: {
    type: String,
    trim: true
  },
  cancelledAt: {
    type: Date,
    index: true
  },
  
  // Metadata
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  notes: {
    type: String,
    trim: true
  },
  
  // â”€â”€ Offline Sync Support â”€â”€
  // offlineId: UUID generated by Flutter when order is created offline
  // Used as deduplication key â€” if two sync requests carry the same offlineId,
  // the second one returns the existing order instead of creating a duplicate
  offlineId: {
    type: String,
    trim: true,
    index: { unique: true, sparse: true } // unique but only for docs that have it
  },
  // When the order was originally created on the device (may differ from server createdAt)
  createdOfflineAt: {
    type: Date
  },
  // Which device created this order (for debugging sync issues)
  deviceId: {
    type: String,
    trim: true
  }
}, {
  timestamps: true
});

// Compound indexes for optimized queries
orderSchema.index({ orderDate: -1, status: 1 });
orderSchema.index({ status: 1, createdAt: -1 });
orderSchema.index({ paymentStatus: 1, createdAt: -1 });
orderSchema.index({ partyName: 1, orderDate: -1 });
orderSchema.index({ mobile: 1, orderDate: -1 });
orderSchema.index({ createdBy: 1, orderDate: -1 });
orderSchema.index({ employee: 1, orderDate: -1 });
orderSchema.index({ employeeName: 1, orderDate: -1 });
orderSchema.index({ expectedDeliveryDate: 1, status: 1 });
orderSchema.index({ deliveryPerformance: 1, orderDate: -1 });
orderSchema.index({ isLocked: 1, status: 1 });
orderSchema.index({ client: 1, status: 1 });
orderSchema.index({ client: 1, paymentStatus: 1 });

// Text index for search
orderSchema.index({ partyName: 'text', mobile: 'text', orderNumber: 'text' });

// Auto-generate order number with race condition handling
orderSchema.pre('save', async function(next) {
  if (this.isNew && !this.orderNumber) {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const prefix = `ORD${year}${month}`;
    
    // Find the highest existing order number for this month
    // This handles deleted orders and gaps in the sequence
    const lastOrder = await mongoose.model('Order').findOne({
      orderNumber: { $regex: `^${prefix}` }
    })
    .select('orderNumber')
    .sort({ orderNumber: -1 })
    .lean();
    
    let nextNumber = 1;
    if (lastOrder && lastOrder.orderNumber) {
      // Extract the number part and increment
      const match = lastOrder.orderNumber.match(/(\d+)$/);
      if (match) {
        nextNumber = parseInt(match[1]) + 1;
      }
    }
    
    // Retry logic to handle race conditions (up to 5 attempts)
    let attempts = 0;
    const maxAttempts = 5;
    let orderNumber = null;
    
    while (attempts < maxAttempts && !orderNumber) {
      // Generate candidate number
      const candidateNumber = `${prefix}${nextNumber.toString().padStart(4, '0')}`;
      
      // Check if this number already exists (atomic check)
      const existing = await mongoose.model('Order').findOne({ 
        orderNumber: candidateNumber 
      }).select('_id').lean();
      
      if (!existing) {
        orderNumber = candidateNumber;
      } else {
        // Number already exists, try next number
        nextNumber++;
        attempts++;
        console.log(`âš ï¸  Order number collision detected: ${candidateNumber}. Retry attempt ${attempts}/${maxAttempts}`);
        
        if (attempts >= maxAttempts) {
          // Fallback: Add timestamp suffix to ensure uniqueness
          const timestamp = Date.now().toString().slice(-4);
          orderNumber = `${prefix}${nextNumber.toString().padStart(4, '0')}_${timestamp}`;
          console.log(`ðŸ”„ Using timestamped order number as fallback: ${orderNumber}`);
        }
      }
    }
    
    this.orderNumber = orderNumber;
  }
  
  // Calculate payment status using effectiveTotal (accounts for returns)
  // effectiveTotal = grandTotal - returnedAmount (what client actually owes for kept items)
  const effectiveTotal = this.grandTotal - (this.returnedAmount || 0);
  
  if (this.advance >= effectiveTotal && effectiveTotal > 0) {
    this.paymentStatus = 'paid';
  } else if (this.advance >= effectiveTotal && effectiveTotal === 0) {
    this.paymentStatus = 'paid'; // Fully returned and nothing owed
  } else if (this.advance > 0) {
    this.paymentStatus = 'partial';
  } else {
    this.paymentStatus = 'unpaid';
  }
  
  // Recalculate balanceDue (always >= 0, overpayment tracked as refundable on client)
  this.balanceDue = Math.max(0, effectiveTotal - (this.advance || 0));
  
  // Calculate remaining quantities
  this.items.forEach(item => {
    item.remainingQuantity = item.quantity - item.deliveredQuantity;
  });
  
  // Calculate progress
  const totalQuantity = this.items.reduce((sum, item) => sum + item.quantity, 0);
  const deliveredQuantity = this.items.reduce((sum, item) => sum + item.deliveredQuantity, 0);
  this.progress = totalQuantity > 0 ? Math.round((deliveredQuantity / totalQuantity) * 100) : 0;
  
  // Update status based on progress AND payment
  // Order only completes when BOTH delivery (100%) AND payment (paid) are done
  const isFullyDelivered = this.progress === 100;
  const isFullyPaid = this.paymentStatus === 'paid';
  
  // Ensure status is never null or undefined - always set a valid value
  if (isFullyDelivered && isFullyPaid) {
    this.status = 'completed';
    this.isLocked = true;
  } else if (isFullyDelivered && !isFullyPaid) {
    this.isLocked = false; // Unlock if returns brought it back from completed
    this.status = 'delivered'; // Delivered but payment pending
  } else if (this.progress > 0 && this.progress < 100) {
    this.isLocked = false; // Unlock â€” returns may have reduced progress
    if (this.status === 'open' || this.status === 'completed' || !this.status || this.status === null) {
      this.status = 'partial_delivered';
    } else if (this.status !== 'partial_delivered' && this.status !== 'in_progress') {
      this.status = 'partial_delivered';
    }
  } else if (this.progress === 0) {
    // No delivery yet - ensure status is 'open'
    if (!this.status || this.status === null || this.status === 'cancelled') {
      // Don't change cancelled status, but ensure others default to 'open'
      if (this.status !== 'cancelled') {
        this.status = 'open';
      }
    }
  }
  
  // Final safety check: ensure status is never null or invalid
  if (!this.status || this.status === null || !['open', 'in_progress', 'partial_delivered', 'delivered', 'completed', 'cancelled'].includes(this.status)) {
    console.warn(`âš ï¸  Invalid status detected: ${this.status}. Defaulting to 'open'. Order: ${this.orderNumber || this._id}`);
    this.status = 'open';
  }
  
  // Calculate delivery performance if actual delivery date exists
  if (this.actualDeliveryDate && this.expectedDeliveryDate) {
    const diffDays = Math.floor((this.actualDeliveryDate - this.expectedDeliveryDate) / (1000 * 60 * 60 * 24));
    if (diffDays < 0) {
      this.deliveryPerformance = 'early';
    } else if (diffDays === 0) {
      this.deliveryPerformance = 'on_time';
    } else {
      this.deliveryPerformance = 'late';
    }
  }
  
  next();
});

module.exports = mongoose.model('Order', orderSchema);

